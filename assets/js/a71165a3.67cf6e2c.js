"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[269],{5318:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7378);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(n),h=a,m=c["".concat(l,".").concat(h)]||c[h]||d[h]||i;return n?r.createElement(m,o(o({ref:t},p),{},{components:n})):r.createElement(m,o({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var u=2;u<i;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6655:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var r=n(2685),a=(n(7378),n(5318));const i={title:"Making Queries",sidebar_position:2},o=void 0,s={unversionedId:"features/queries-philosophy",id:"features/queries-philosophy",title:"Making Queries",description:"Joist has several ways to query entities, and which to use depends on how much control you need over the query.",source:"@site/docs/features/queries-philosophy.md",sourceDirName:"features",slug:"/features/queries-philosophy",permalink:"/docs/features/queries-philosophy",draft:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/features/queries-philosophy.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Making Queries",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Entity Manager",permalink:"/docs/features/entity-manager"},next:{title:"Find Queries",permalink:"/docs/features/queries-find"}},l={},u=[{value:"Philosophy",id:"philosophy",level:2},{value:"Approaches",id:"approaches",level:2},{value:"1. Object Graph Navigation",id:"1-object-graph-navigation",level:3},{value:"2. Find Queries",id:"2-find-queries",level:3},{value:"3. Other Query Builders",id:"3-other-query-builders",level:3},{value:"<code>buildQuery</code>",id:"buildquery",level:4}],p={toc:u};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Joist has several ways to query entities, and which to use depends on how much control you need over the query."),(0,a.kt)("h2",{id:"philosophy"},"Philosophy"),(0,a.kt)("p",null,"Joist's primary focus is not \"",(0,a.kt)("em",{parentName:"p"},"never"),' having to hand-write SQL", so it is not a full-fledged query builder (like ',(0,a.kt)("a",{parentName:"p",href:"https://knexjs.org/"},"Knex")," or ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/koskimas/kysely"},"Kelsey"),"); instead it focuses on robust domain modeling, with validation rules, reactive derived values, etc."),(0,a.kt)("p",null,"So it's expected to, for sufficiently advanced/complicated queries, use a 3rd party query builder in addition to Joist, as covered in Approach 3."),(0,a.kt)("h2",{id:"approaches"},"Approaches"),(0,a.kt)("p",null,"Loading entities is a core feature of ORMs, and Joist supports several ways of doing this:"),(0,a.kt)("h3",{id:"1-object-graph-navigation"},"1. Object Graph Navigation"),(0,a.kt)("p",null,'This is the bread & butter of ORMs, and involves just "walking the graph" from some entity you already have, to other entities that are related to it. Examples are:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'// Calling .load() methods directly\nconst author = await book.author.load();\n// Using a lens\nconst reviews = await publisher.load(p => p.books.reviews);\n// Using populate + gets\nconst loaded = author.populate({ books: "reviews" });\nloaded.books.get.flatMap(b => b.reviews.get);\n')),(0,a.kt)("p",null,"This pattern will likely be ",(0,a.kt)("strong",{parentName:"p"},"~90% of the queries"),' in your app, and are so pervasive/ergonomic that you likely won\'t even think of them as "making SQL queries".'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Pro: The most succinct way of loading entities."),(0,a.kt)("li",{parentName:"ul"},"Pro: Joist guarantees these will not N+1, even if called in a loop."),(0,a.kt)("li",{parentName:"ul"},"Pro: Works with non-database/domain model-only relations like Joist's ",(0,a.kt)("inlineCode",{parentName:"li"},"hasOneDerived"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"hasOneThrough"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"AsyncProperties"),", etc."),(0,a.kt)("li",{parentName:"ul"},"Con: Generally object graph navigation loads all entities within the sub-graph you're walking, i.e. you can't say \"return only ",(0,a.kt)("em",{parentName:"li"},"out of stock"),' books" (see ',(0,a.kt)("inlineCode",{parentName:"li"},"find")," queries next)")),(0,a.kt)("h3",{id:"2-find-queries"},"2. Find Queries"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"EntityManager.find")," queries are a middle-ground that allow database-side filtering of rows, and so return only a subset of data (instead of the full subgraph like approach 1). Examples are:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'const r1 = await em.find(Book, { author: { firstName: "b1" } });\nconst r2 = await em.find(Publisher, { authors: { firstName: "b1" } });\nconst r3 = await em.find(Author, { firstName: { like: "%a%" } });\nconst r4 = await em.find(Author, { publisher: p1 });\n')),(0,a.kt)("p",null,"If object graph navigation is ~80-90% of your application's queries (because they are all implicit), ",(0,a.kt)("inlineCode",{parentName:"p"},"find")," queries will likely be ",(0,a.kt)("strong",{parentName:"p"},"~10% of your queries"),"."),(0,a.kt)("p",null,"See ",(0,a.kt)("a",{parentName:"p",href:"./queries-find"},"Find Queries")," for more documentation and examples."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Pro: Still succinct because joins are implicit in the object literal"),(0,a.kt)("li",{parentName:"ul"},"Pro: Supports ",(0,a.kt)("inlineCode",{parentName:"li"},"WHERE"),"-based filtering/returning a subset of entities"),(0,a.kt)("li",{parentName:"ul"},"Con: Not as N+1 safe as approach 1; Joist currently ",(0,a.kt)("em",{parentName:"li"},"attempts")," to de-N+1 these queries, but it's not perfect. See ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/stephenh/joist-ts/issues/441"},"this issue")," for details."),(0,a.kt)("li",{parentName:"ul"},"Con: Cannot use domain model-level relations like Joist's ",(0,a.kt)("inlineCode",{parentName:"li"},"hasOneDerived"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"hasOneThrough"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"AsyncProperties"),", etc."),(0,a.kt)("li",{parentName:"ul"},"Con: Loads only full entities, not cross-table aggregates/group bys/etc.")),(0,a.kt)("h3",{id:"3-other-query-builders"},"3. Other Query Builders"),(0,a.kt)("p",null,"For query that grow outside of what ",(0,a.kt)("inlineCode",{parentName:"p"},"em.find")," can provide, then it's perfectly fine to use a 3rd-party query builder like ",(0,a.kt)("a",{parentName:"p",href:"https://knexjs.org/"},"Knex")," or ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/koskimas/kysely"},"Kelsey"),"."),(0,a.kt)("p",null,"Knex would be a natural choice, because Joist uses Knex as an internal dependency, but Kelsey would be fine too."),(0,a.kt)("p",null,"In particular, any queries that need to:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do group bys/aggregates"),(0,a.kt)("li",{parentName:"ul"},"Select custom fragments of data (not just an entity)")),(0,a.kt)("p",null,"Are best done via Knex or Kysely."),(0,a.kt)("h4",{id:"buildquery"},(0,a.kt)("inlineCode",{parentName:"h4"},"buildQuery")),(0,a.kt)("p",null,"Joist does provide a ",(0,a.kt)("inlineCode",{parentName:"p"},"buildQuery")," method that allows blending approaches 2 and 3: you can pass an ",(0,a.kt)("inlineCode",{parentName:"p"},"em.find")," join literal to ",(0,a.kt)("inlineCode",{parentName:"p"},"buildQuery"),", and get back a Knex ",(0,a.kt)("inlineCode",{parentName:"p"},"QueryBuilder")," with all the joins added, to which you can do your own further joins or filters."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'const query = buildQuery(knex, Book, {\n  where: { author: [a1, a2] },\n});\n// Use knex methods to continue building the query0\nquery.whereNotNull("parent_bill_id");\n// Then load the entities with the customizing query\nconst books = await em.loadFromQuery(Book, query);\n')),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"The first three options all focus on loading ",(0,a.kt)("em",{parentName:"p"},"entities"),", which your code will then iterate over to perform business/view logic."),(0,a.kt)("p",{parentName:"admonition"},"If you need to load bespoke, non-entity fragments of data across several tables (i.e. with aggregates/group bys/etc.), that is currently not a feature that Joist provides, but you're free to use a raw query builder, which is fourth option in the above list.")))}d.isMDXComponent=!0}}]);